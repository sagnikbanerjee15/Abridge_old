#! /usr/bin/env python3

#####################################################################################################################################################################
#
# A standalone script created for the purpose of testing abridge
# Script does not take any inputs and all the required information is hard coded intentionally to prevent it from being accidentally executed in the future
# Script will also perform download and alignment of all sequences
# Can be executed without any changes on Ceres
# 
# Tests carried out by this script:
#     - 2 types of STAR alignments - one with 
# 
#####################################################################################################################################################################

import os
import sys
import multiprocessing
import time
import random

CPU = 128

def runDockerCommand( name, version, image_location, container_name, volumes, command , cpus = 1, memory = '1g' ):
    """
    Runs the command in a docker container
    """

    # Runs the main command
    docker_cmd = f" docker run "
    # docker_cmd += f" -ti "
    docker_cmd += f" --rm "
    docker_cmd += f" --cpus={cpus}"
    docker_cmd += f" --memory='{memory}'"
    # docker_cmd += f" --name {container_name}"
    for mapping in volumes:
        docker_cmd += f" -v {mapping}"
    docker_cmd += f" {image_location}:{version} "
    docker_cmd += f" bash -c '{command}'"
    #logging.info( f"Running command - {docker_cmd}" )
    os.system( docker_cmd )
    #print( docker_cmd )
    #sys.exit()

def runSingularityCommand(name, version, image_location, container_name, volumes, command , cpus = 1, memory = '1g' ):
    """
    Runs the command in a Singularity container
    """

    # Runs the main command
    
    if "sratools" not in image_location:
        singularity_cmd = f" singularity exec  "
        for mapping in volumes:
            singularity_cmd += f" -B {mapping}"
        singularity_cmd += f" {image_location} "
        singularity_cmd += f" bash -c '{command}'"
    else:
        singularity_cmd = f" singularity exec  "
        for mapping in volumes:
            singularity_cmd += f" -B {mapping}"
        singularity_cmd += f" {image_location} "
        singularity_cmd += f" {command}"
    os.system( singularity_cmd )
    

def executeCommand(framework_of_choice, software, version, volumes_list, singularity_sif_location, memory, cmd1):
    """
    Executes the command within the requested framework
    """
    if framework_of_choice == "docker":
        runDockerCommand( 
                          name = software,
                            version = version,
                            image_location = f"ghcr.io/sagnikbanerjee15/dockerized_tools_and_pipelines/{software}",
                            container_name = f"{software}",
                            volumes = volumes_list,
                            command = cmd1,
                            cpus = CPU,
                            memory = memory
            )
    elif framework_of_choice == "singularity":
        runSingularityCommand( 
                            name = software,
                            version = version,
                            image_location = singularity_sif_location,
                            container_name = f"{software}",
                            volumes = volumes_list,
                            command = cmd1,
                            cpus = CPU,
                            memory = memory
                            )

def runCommand( eachinput ):
    Run, cmd1, cmd2 = eachinput
    #time.sleep(wait_time * random.randint(2,5))
    os.system( cmd1 )
    #os.system( cmd2 )
    
    

def main():

    OUTPUT_DIRECTORY_MAIN = "/work/ABRIDGE/testing"
    
    sra_id = "SRR13711353"
    
    pool = multiprocessing.Pool( processes = int( CPU ) )
    os.system(f"mkdir -p {OUTPUT_DIRECTORY_MAIN}/abridge_compressed")
    os.system(f"mkdir -p {OUTPUT_DIRECTORY_MAIN}/abridge_decompressed")
    
    
    ########################################################################################################################
    # Compress
    ########################################################################################################################
    
    allinputs = []
    i=0
    for ended in ["SE","PE"]:
        #if ended == "PE": continue
        for alignment_type in ["all_tags_sorted", "no_tags_unsorted"]:
            #if alignment_type == "all_tags_sorted": continue
            alignment_filename = f"{OUTPUT_DIRECTORY_MAIN}/alignments/{sra_id}_{ended}_{alignment_type}_1.sam"
            for ignore_alignment_scores in [0, 1]:
                #if ignore_alignment_scores == 1: continue
                for ignore_all_quality_scores in [0, 1]:
                    #if ignore_all_quality_scores == 1: continue
                    for ignore_quality_scores_for_matched_bases in [0, 1]:
                        #if ignore_quality_scores_for_matched_bases == 1: continue
                        for ignore_soft_clippings in [0, 1]:
                            #if ignore_soft_clippings == 1: continue
                            for ignore_mismatches in [0, 1]:
                                #if ignore_mismatches == 1: continue
                                for ignore_unmapped_reads in [0, 1]:
                                    #if ignore_unmapped_reads == 1: continue
                                    for skip_shortening_read_names in [0, 1]:
                                        #if skip_shortening_read_names == 1: continue 
                                        
                                        output_directory_main = f"{OUTPUT_DIRECTORY_MAIN}/abridge_compressed/{sra_id}_{ended}_{alignment_type}_i_align_sc_{ignore_alignment_scores}_i_all_qual_sc_{ignore_all_quality_scores}_i_qual_sc_matched_bases_{ignore_quality_scores_for_matched_bases}_i_soft_clippings_{ignore_soft_clippings}_i_mismatches_{ignore_mismatches}_i_unmapped_reads_{ignore_unmapped_reads}_skip_shrtnng_rn_{skip_shortening_read_names}"
                                        cmd1  = f" /work/ABRIDGE/Abridge/abridge "
                                        cmd1 += f" --compress "
                                        
                                        if ignore_alignment_scores == 1:
                                            cmd1 += f" --ignore_alignment_scores "
                                        if ignore_all_quality_scores == 1:
                                            cmd1 += f" --ignore_all_quality_scores "
                                        if ignore_quality_scores_for_matched_bases == 1:
                                            cmd1 += f" --ignore_quality_scores_for_matched_bases "
                                        if ignore_soft_clippings == 1:
                                            cmd1 += " --ignore_soft_clippings "
                                        if ignore_mismatches == 1:
                                            cmd1 += " --ignore_mismatches "
                                        if ignore_unmapped_reads == 1:
                                            cmd1 += " --ignore_unmapped_reads "
                                        if skip_shortening_read_names == 1:
                                            cmd1 += f" --skip_shortening_read_names "
                                            
                                        cmd1 += f" --inputalignedfilename  {alignment_filename} "
                                        cmd1 += f" --genome /work/ABRIDGE/testing/reference/Arabidopsis_thaliana.TAIR10.dna.toplevel.fa "
                                        cmd1 += f" --keep_intermediate_error_files "
                                        cmd1 += f" --preserve_all_intermediate_files "
                                        cmd1 += f" --output_directory {output_directory_main}"
                                        cmd1 += f" --software_directory /project/maizegdb/sagnik/ABRIDGE/testing/singularity_images"
                                        cmd1 += f" --framework docker "
                                        cmd1 += f" 1> {output_directory_main}.output "
                                        cmd1 += f" 2> {output_directory_main}.error"
                                        
                                        if os.path.exists(f"{output_directory_main}/{sra_id}_{ended}_{alignment_type}_1.abridge") == False:
                                            allinputs.append( ["dummy", cmd1, "ls"] )
                                            i+=1
    pool.map( runCommand, allinputs )
    #return
    
    
    ########################################################################################################################
    # Decompress
    ########################################################################################################################
    allinputs = []
    i=0
    os.chdir(f"{OUTPUT_DIRECTORY_MAIN}/abridge_decompressed")
    for ended in ["SE","PE"]:
        #if ended == "SE": continue
        for alignment_type in ["all_tags_sorted", "no_tags_unsorted"]:
            #if alignment_type == "no_tags_unsorted": continue
            alignment_filename = f"{OUTPUT_DIRECTORY_MAIN}/alignments/{sra_id}_{ended}_{alignment_type}_1.sam"
            for ignore_alignment_scores in [0, 1]:
                #if ignore_alignment_scores == 1: continue
                for ignore_all_quality_scores in [0, 1]:
                    #if ignore_all_quality_scores == 1: continue
                    for ignore_quality_scores_for_matched_bases in [0, 1]:
                        #if ignore_quality_scores_for_matched_bases == 1: continue
                        for ignore_soft_clippings in [0, 1]:
                            #if ignore_soft_clippings == 1: continue
                            for ignore_mismatches in [0, 1]:
                                #if ignore_mismatches == 1: continue
                                for ignore_unmapped_reads in [0, 1]:
                                    #if ignore_unmapped_reads == 1: continue
                                    for skip_shortening_read_names in [0, 1]:
                                        #if skip_shortening_read_names == 1: continue   
                                        for quality in [0, 1]:
                                            #if quality == 0: continue
                                            for ignore_sequence in [0, 1]:
                                                #if ignore_sequence == 1:continue
                                                output_directory_main = f"{OUTPUT_DIRECTORY_MAIN}/abridge_decompressed/{sra_id}_{ended}_{alignment_type}_i_align_sc_{ignore_alignment_scores}_i_all_qual_sc_{ignore_all_quality_scores}_i_qual_sc_matched_bases_{ignore_quality_scores_for_matched_bases}_i_soft_clippings_{ignore_soft_clippings}_i_mismatches_{ignore_mismatches}_i_unmapped_reads_{ignore_unmapped_reads}_skip_shrtnng_rn_{skip_shortening_read_names}_quality_{quality}_i_seq_{ignore_sequence}"
                                                compressed_filename = f"{OUTPUT_DIRECTORY_MAIN}/abridge_compressed/{sra_id}_{ended}_{alignment_type}_i_align_sc_{ignore_alignment_scores}_i_all_qual_sc_{ignore_all_quality_scores}_i_qual_sc_matched_bases_{ignore_quality_scores_for_matched_bases}_i_soft_clippings_{ignore_soft_clippings}_i_mismatches_{ignore_mismatches}_i_unmapped_reads_{ignore_unmapped_reads}_skip_shrtnng_rn_{skip_shortening_read_names}/{sra_id}_{ended}_{alignment_type}_1.abridge"
                                                              
                                                cmd1  = f" /work/ABRIDGE/Abridge/abridge "
                                                cmd1 += f" --decompress "
                                                cmd1 += f" --inputabrfilename  {compressed_filename} "
                                                cmd1 += f" --genome /work/ABRIDGE/testing/reference/Arabidopsis_thaliana.TAIR10.dna.toplevel.fa "
                                                cmd1 += f" --keep_intermediate_error_files "
                                                cmd1 += f" --preserve_all_intermediate_files "
                                                cmd1 += f" --output_directory {output_directory_main}"
                                                if quality == 1:
                                                    cmd1 += f" --quality C "
                                                if ignore_sequence == 1:
                                                    cmd1 += f" --ignore_sequence "
                                                cmd1 += f" --framework docker "
                                                cmd1 += f" --software_directory /project/maizegdb/sagnik/ABRIDGE/testing/singularity_images"
                                                cmd1 += f" 1> {output_directory_main}.output "
                                                cmd1 += f" 2> {output_directory_main}.error"
                                                
                                                #print(f"{output_directory_temp}/{sra_id}_{ended}_{alignment_type[:-3]}_decompressed.sam")
                                                if os.path.exists(f"{output_directory_main}/{sra_id}_{ended}_{alignment_type}_1_decompressed.sam") == False:
                                                    #print(cmd1)
                                                    allinputs.append( ["dummy", cmd1, i] )
                                                    i+=1
    pool.map( runCommand, allinputs )
    #print(len(allinputs))
    
    allinputs = []
    # Convert SAM to BAM to ensure that the decompression worked fine
    for ended in ["SE","PE"]:
        #if ended == "SE": continue
        for alignment_type in ["all_tags_sorted", "no_tags_unsorted"]:
            #if alignment_type == "no_tags_unsorted": continue
            alignment_filename = f"{OUTPUT_DIRECTORY_MAIN}/alignments/{sra_id}_{ended}_{alignment_type}_1.sam"
            for ignore_alignment_scores in [0, 1]:
                #if ignore_alignment_scores == 1: continue
                for ignore_all_quality_scores in [0, 1]:
                    #if ignore_all_quality_scores == 1: continue
                    for ignore_quality_scores_for_matched_bases in [0, 1]:
                        #if ignore_quality_scores_for_matched_bases == 1: continue
                        for ignore_soft_clippings in [0, 1]:
                            #if ignore_soft_clippings == 1: continue
                            for ignore_mismatches in [0, 1]:
                                #if ignore_mismatches == 1: continue
                                for ignore_unmapped_reads in [0, 1]:
                                    #if ignore_unmapped_reads == 1: continue
                                    for skip_shortening_read_names in [0, 1]:
                                        #if skip_shortening_read_names == 1: continue   
                                        for quality in [0, 1]:
                                            #if quality == 0: continue
                                            for ignore_sequence in [0, 1]:
                                                #if ignore_sequence == 1:continue
                                                output_directory_main = f"{OUTPUT_DIRECTORY_MAIN}/abridge_decompressed/{sra_id}_{ended}_{alignment_type}_i_align_sc_{ignore_alignment_scores}_i_all_qual_sc_{ignore_all_quality_scores}_i_qual_sc_matched_bases_{ignore_quality_scores_for_matched_bases}_i_soft_clippings_{ignore_soft_clippings}_i_mismatches_{ignore_mismatches}_i_unmapped_reads_{ignore_unmapped_reads}_skip_shrtnng_rn_{skip_shortening_read_names}_quality_{quality}_i_seq_{ignore_sequence}"
                                                compressed_filename = f"{OUTPUT_DIRECTORY_MAIN}/abridge_compressed/{sra_id}_{ended}_{alignment_type}_i_align_sc_{ignore_alignment_scores}_i_all_qual_sc_{ignore_all_quality_scores}_i_qual_sc_matched_bases_{ignore_quality_scores_for_matched_bases}_i_soft_clippings_{ignore_soft_clippings}_i_mismatches_{ignore_mismatches}_i_unmapped_reads_{ignore_unmapped_reads}_skip_shrtnng_rn_{skip_shortening_read_names}/{sra_id}_{ended}_{alignment_type}_1.abridge"
                                                 
                                                cmd2  = f"samtools view"
                                                cmd2 += f" -@ 1 "
                                                cmd2 += f" -Sb "
                                                cmd2 += f" -o {output_directory_main}/{sra_id}_{ended}_{alignment_type}_1_decompressed.bam "
                                                cmd2 += f" {output_directory_main}/{sra_id}_{ended}_{alignment_type}_1_decompressed.sam "
                                                cmd2 += f" 1> {output_directory_main}/{sra_id}_{ended}_{alignment_type}_1_decompressed_convert_to_bam.output "
                                                cmd2 += f" 2> {output_directory_main}/{sra_id}_{ended}_{alignment_type}_1_decompressed_convert_to_bam.error " 
                                                
                                                software = "samtools"    
                                                container_name = f"{sra_id}_{ended}_{alignment_type}_i_align_sc_{ignore_alignment_scores}_i_all_qual_sc_{ignore_all_quality_scores}_i_qual_sc_matched_bases_{ignore_quality_scores_for_matched_bases}_i_soft_clippings_{ignore_soft_clippings}_i_mismatches_{ignore_mismatches}_i_unmapped_reads_{ignore_unmapped_reads}_skip_shrtnng_rn_{skip_shortening_read_names}_quality_{quality}_i_seq_{ignore_sequence}"
                                                volumes = [f"{OUTPUT_DIRECTORY_MAIN}:{OUTPUT_DIRECTORY_MAIN}"]
                                                version = "1.14"
                                                if os.path.exists(f"{output_directory_main}/{sra_id}_{ended}_{alignment_type}_1_decompressed.bam") == False:
                                                    #print(cmd2)
                                                    #runDockerCommand( name = "xyz", version = "1.14", image_location = f"ghcr.io/sagnikbanerjee15/dockerized_tools_and_pipelines/{software}", container_name = container_name, volumes = volumes, command = cmd2 , cpus = CPU, memory = '25g' )
                                                    # Runs the main command
                                                    docker_cmd = f" docker run "
                                                    # docker_cmd += f" -ti "
                                                    docker_cmd += f" --rm "
                                                    docker_cmd += f" --cpus=1"
                                                    docker_cmd += f" --memory='25g'"
                                                    # docker_cmd += f" --name {container_name}"
                                                    for mapping in volumes:
                                                        docker_cmd += f" -v {mapping}"
                                                    docker_cmd += f" ghcr.io/sagnikbanerjee15/dockerized_tools_and_pipelines/{software}:{version} "
                                                    docker_cmd += f" bash -c '{cmd2}'"
                                                    #logging.info( f"Running command - {docker_cmd}" )
                                                    # os.system( docker_cmd )
                                                    allinputs.append( ["dummy", docker_cmd, i] )

    pool.map( runCommand, allinputs )
    
    
if __name__ == "__main__":
    main()