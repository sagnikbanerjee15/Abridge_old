#! /usr/bin/env python3

########################################################################################################################################################
# Script for running abridge within docker container
########################################################################################################################################################

import argparse 
import logging
import os
import pprint
import sys
import re
import time
import multiprocessing
import random
import glob
import time
import subprocess
from pprint import pformat
from scripts.run_abridge import parseCommandLineArguments

class DockerOperations:
    
    def __init__(self, image_name, image_version, container_name, volumes, temp_file_name):
        self.image_name = image_name
        self.image_version = image_version
        self.container_name = container_name
        self.volumes = volumes
        self.temp_file_name = temp_file_name
        
    def runCommand(self, cmd):
        
        # Check to make sure the container does not exist
        cmd  = f" docker "
        cmd += f" inspect --format '{{json .State.Stopped}}' "
        cmd += f" {self.container_name} "
        cmd += f" > {self.temp_file_name}"
        os.system(cmd)
        
        status = open(f"{self.temp_file_name}").read().strip("\n")
        if status == "running" or status == "exited":
            return
            
        docker_cmd  = f" docker run "
        docker_cmd += f" --rm "
        docker_cmd += f" --name {self.container_name} "
        for mapping in self.volumes:
            docker_cmd += f" -v {mapping} "
        docker_cmd += f" {self.image_name}:{self_image_version} "
        docker_cmd += f" bash -c {cmd}"
        os.system(docker_cmd)

def main():
    commandLineArg=sys.argv
    if len(commandLineArg)==1:
        print("Please use the --help option to get usage information")
    options=parseCommandLineArguments()
    
    output_filename = f"{options.error_directory}.output"
    error_filename = f"{options.error_directory}.error"
    
    if options.test ==  True:
        pass
    else:
        cmd  = f" run_abridge "
        for key,value in options.__dict__.items():
            if value is not None:
                cmd += f" --{key} {value}"
        cmd += f" > {output_filename}"
        cmd += f" > {error_filename}"
        print(cmd)
        

if __name__ == "__main__":
    main()
